% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/asr.R
\name{asr.marginal.classe}
\alias{asr.marginal.classe}
\title{Ancestral State Reconstruction for ClaSSE/GeoSSE Models}
\usage{
asr.marginal.classe(lik, pars, nodes = NULL, ...)
}
\arguments{
\item{lik}{A likelihood function created by \code{make.classe} or related functions.}

\item{pars}{A vector of parameters suitable for the likelihood function.}

\item{nodes}{An optional vector of nodes to return ancestral states for (using ape's
node indexing). By default, all internal nodes are returned.}

\item{...}{Additional arguments passed through to the reconstruction function,
including root conditions and survival conditioning.}
}
\value{
A matrix where each column represents a node and each row represents
a character state. The values are the marginal probabilities of each state
at each node.
}
\description{
Perform marginal ancestral state reconstruction for classe models. This function
computes the marginal probability of each state at ancestral nodes given the
observed tip states and model parameters.
}
\details{
This function performs marginal ancestral state reconstruction, computing the
probability distribution over character states at each ancestral node. The
reconstruction takes into account the phylogenetic relationships, branch lengths,
and the evolutionary model specified in the likelihood function.

The function is a wrapper that creates and calls the reconstruction function
using \code{make.asr.marginal.classe}.
}
\examples{
#------- Toy dataset, parameters given
data(phy5)
cols <- plyr::mapvalues(phy5$tip.state_3, from = c(1:3), to=c('black', "blue","red" ))
plot(phy5, label.offset = 2, cex=1, no.margin = FALSE)
tiplabels(pch = 15, col = cols, cex = 2, adj = 1.5)
nodelabels()
tiplabels()
edgelabels()
axisPhylo()

lik.td <-make.classe.td(phy5, phy5$tip.state_3, k=3, n.epoch=2, control=list(backend = "gslode"),
 strict=TRUE)
par.td <- c(4, c(1:54)/100)
names(par.td) <- diversitree::argnames(lik.td)
lik.est <- lik.td(par.td, intermediates=TRUE)
print(lik.est)

st <-  asr.marginal.classe(lik.td, par.td)
nodelabels(thermo=t(st), piecol=c('black', "blue","red"), cex=2, adj=.5)


\dontrun{
file_path <- system.file("extdata", "geosse_tb_tree.rds", package = "divextra")
phy <- readRDS(file_path)
plot(phy)

file_path <- system.file("extdata", "geosse3_td_test.yml", package = "divextra")
par.categories.td <- read_yaml_pars_td(file_path)
# display
print(par.categories.td)

lik.td <-make.classe.td(phy, phy$tip.state, k=3, n.epoch=2, control=list(backend = "gslode"),
 strict=TRUE)
formula.td <- make_constraints_sse_td(par.categories.td)
lik.const.td <- constrain(lik.td, formulae = formula.td)
starting.point <- init.pars.classe_td(lik.const.td, phy, k=3, n.epoch=2, eps=0.5)
print(starting.point)

mle.td <- find.mle(lik.const.td, starting.point, condition.surv=TRUE, keep.func=FALSE)

st <- asr.marginal.classe(lik.td, mle.td$par.full)

cols <- plyr::mapvalues(phy$tip.state, from = c(1:3), to=c('orange', "green","red" ))
plot(phy, show.tip.label = FALSE, cex=1, no.margin = FALSE)
tiplabels(pch = 15, col = cols, cex = .5, adj = 1)
nodelabels(thermo=t(st), piecol=c('orange', "green","red" ), cex=.3, adj=0)
}

}
\seealso{
\code{\link{make.asr.marginal.classe}} for the function factory version,
\code{asr.marginal} in the diversitree package for the generic function.
}
